<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Nanum+Gothic&display=swap">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.8.2/css/all.min.css" />
    <title>Document</title>
    <script src="/js/fabric.js"></script>
</head>

<body>
    <style>
        body {
            padding: 0;
            margin: 0;
            font-family: consolas;
            font-size: 12px;
        }

        .canvas-wrapper {
            position: relative;   
            top: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            background-color: transparent;
        }
        .canvas-container {
            float: left;
        }
        #c1 {
            width: calc(50% - 2px);
            border-right: 2px dashed darkgray;
        }
        #c2 {
            width: calc(50% - 2px);
        }

        .custom-wrapper {
            position: relative;
            border: 2px solid #2FDBB6;
            width: 530px;
            height: 143px;
        }

    </style>

<div class="mainArea">
    <div class="canvas-wrapper">
        <canvas id="c1"> </canvas>
        <canvas id="c2"> </canvas>
    </div>
    <div class="custom-wrapper">
        <div>
            <button id='SaveDataToDB'>SaveDataToDB</button>
        </div>

    </div>


</div>    


    <!-- JSON 넣는 곳-->
    <form id="form" method="post">
        <input type="hidden" id="json" name="json">
    </form>


    <!--jQuery CDN -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
        integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>

    <script>
        //create two canvases
        var canvasSticker = document.getElementById("c1");
        canvasSticker.width = 700;
        canvasSticker.height = 600;

        var canvasScene = document.getElementById("c2");
        canvasScene.width = 700;
        canvasScene.height = 600;
        // canvasScene.width = canvasScene.offsetWidth;
        // canvasScene.height = canvasScene.parentElement.offsetHeight;

        var canvas1 = new fabric.Canvas('c1');
        canvas1.setBackgroundColor('rgba(19, 19, 19, 0.25)');
        canvas1.renderAll();

        var canvas2 = new fabric.Canvas('c2');
        canvas2.setBackgroundColor('rgba(92, 18, 18, 0.25)');
        canvas2.renderAll();

        // add loaded image on canvas1
        var onImageLoaded = function (oImg) {
            oImg.originX = "center";
            oImg.originY = "center";

            oImg.left = this.x;
            oImg.top = this.y;

            canvas1.add(oImg);
            oImg.canvas = canvas1;
            imgArrow = oImg;
        };

        var config = { crossOrigin: 'anonymous' };


        var url0 = "img/mickey.png";
        var url1 = "img/mini.png";
        var url2 = "img/duck3.png";

        // load some images
        // canvas1에 스티커당 5개씩 로딩해둘까
        // 그럼 canvas2로 옮겨도 canvas1에 스티커 여분이 남아있다
        for (var i = 0; i < 5; i++) {
            fabric.Image.fromURL(url0, onImageLoaded.bind({ x: 156, y: 196 }), config);
            fabric.Image.fromURL(url1, onImageLoaded.bind({ x: 506, y: 4 * 96 }), config);
            fabric.Image.fromURL(url2, onImageLoaded.bind({ x: 206, y: 5 * 96 }), config);
        }


        //
        var onObjectMoving = function (p) {
            var viewport = p.target.canvas.calcViewportBoundaries();

            if (p.target.canvas === canvas1) {
                if (p.target.left > viewport.br.x) {
                    console.log("Migrate: left -> center");
                    migrateItem(canvas1, canvas2, p.target);
                    return;
                }
            }
            if (p.target.canvas === canvas2) {
                if (p.target.left < viewport.tl.x) {
                    console.log("Migrate: center -> left");
                    migrateItem(canvas2, canvas1, p.target);
                    return;
                }
            }
        };

        canvas1.on("object:moving", onObjectMoving);
        canvas2.on("object:moving", onObjectMoving);

        // isTouchDevice 정의
        var isTouchDevice = 'ontouchstart' in window || navigator.msMaxTouchPoints;

        // start of var migrateItem
        var migrateItem = function (fromCanvas, toCanvas, pendingImage) {
            // Just drop image from old canvas
            // 지우지 않고 옮기기만 하면 old canvas와 new canvas 경계선에 걸려있음
            fromCanvas.remove(pendingImage);

            // We're going to trick fabric.js,
            // so we keep internal transforms of the source canvas, 
            // in order to inject it into destination canvas.
            var pendingTransform = fromCanvas._currentTransform;
            fromCanvas._currentTransform = null;

            // Make shortcuts for fabric.util.removeListener and fabric.util.addListener
            var removeListener = fabric.util.removeListener;
            var addListener = fabric.util.addListener;

            // Re-arrange subscriptions for source canvas
            {
                removeListener(fabric.document, 'mouseup', fromCanvas._onMouseUp);
                removeListener(fabric.document, 'touchend', fromCanvas._onMouseUp);

                removeListener(fabric.document, 'mousemove', fromCanvas._onMouseMove);
                removeListener(fabric.document, 'touchmove', fromCanvas._onMouseMove);

                addListener(fromCanvas.upperCanvasEl, 'mousemove', fromCanvas._onMouseMove);
                addListener(fromCanvas.upperCanvasEl, 'touchmove', fromCanvas._onMouseMove, {
                    passive: false
                });

                if (isTouchDevice) {
                    // Wait 500ms before rebinding mousedown to prevent double triggers
                    // from touch devices
                    var _this = fromCanvas;
                    setTimeout(function () {
                        addListener(_this.upperCanvasEl, 'mousedown', _this._onMouseDown);
                    }, 500);
                }
            }

            // Re-arrange subscriptions for destination canvas
            {
                addListener(fabric.document, 'touchend', toCanvas._onMouseUp, {
                    passive: false
                });
                addListener(fabric.document, 'touchmove', toCanvas._onMouseMove, {
                    passive: false
                });

                removeListener(toCanvas.upperCanvasEl, 'mousemove', toCanvas._onMouseMove);
                removeListener(toCanvas.upperCanvasEl, 'touchmove', toCanvas._onMouseMove);



                if (isTouchDevice) {
                    // Unbind mousedown to prevent double triggers from touch devices
                    removeListener(toCanvas.upperCanvasEl, 'mousedown', toCanvas._onMouseDown);
                } else {
                    addListener(fabric.document, 'mouseup', toCanvas._onMouseUp);
                    addListener(fabric.document, 'mousemove', toCanvas._onMouseMove);
                }
            }

            // We need this timer, because we want Fabric.js to complete pending render
            // before we inject, because it causes some unpleasant image jumping.
            setTimeout(function () {
                // Add image to destination canvas,
                pendingImage.scaleX *= -1;
                pendingImage.canvas = toCanvas;
                pendingImage.migrated = true;
                toCanvas.add(pendingImage);

                // and inject transforms from source canvas
                toCanvas._currentTransform = pendingTransform;

                // as we have mirrored the image, we mirror transforms too
                toCanvas._currentTransform.scaleX *= -1;
                toCanvas._currentTransform.original.scaleX *= -1;

                // finally don't forget to make pasted object selected
                toCanvas.setActiveObject(pendingImage);
            }, 10);
        }; // end of var migrateItem



        // DB에 저장되는 버튼
        $("#SaveDataToDB").click(function () {

            var $form = $("#form");
            // JSON 처리
            var obJSON = canvas2.toJSON();
            console.log(JSON.stringify(obJSON));

            // json은 직렬화해서 form으로 보냄
            $("#json").val(JSON.stringify(obJSON));

            // 그럼 controller에 있는 post 맵핑이 받고
            // DB에 insert함
            $form.submit();

        });


    </script>
</body>

</html>